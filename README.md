3.19：大致完成功能，获取票据和查询票数在没有缓存的情况下，达到800qps；投票接口使用redis分布式锁实现，测试下来只有200qps，打算明天试一试其他方案。

3.20：测试了 mysql 自带的锁和 我们自己实现的乐观锁，发现 qps 没有明显上升，并且由于这两种情况会导致 mysql 压力大，会出现大量慢sql，目前选择继续使用redis。

项目结构整理，查询获票接口大概 400qps，获取票据接口大概 800pqs，投票接口大概200pqs；下阶段考虑先优化投票接口，尝试引入MQ试试。

着手引入MQ了，代码写到一半，发现引入MQ的代价太大了，并且项目的复杂度会变高很多，会需要考虑更多问题，并且最终还是需要将数据持久化到数据库中，时间不是很充分，决定还是在原有基础上进行优化吧。

目前能想到的是，通过 redis 定期缓存所有选手的投票情况，然后采用 “缓存过期” 策略进行缓存的更新，即缓存失效后，再从数据库拿新数据进行更新。因为对于查询目前投票数这种情况，对于数据的实时性要求不高，只需要做到最终一致性即可。

写redis缓存过程中，发现投票的次数超过上限任然可以使用，这里解决了一下bug，将两个sql合并成一个，并且意外提升了性能。投票性能达到 200+qps。
计划：（1）明天通过引入redis缓存所有选手的获得票数，来提升查询票数的qps；
（2）再通过将扣减使用次数这个操作，放到redis中去做，减少我们的mysql数据库压力，进一步提升pqs。

3.21：通过缓存获票数，将性能提升一倍，qps 达到600左右；
目前三个接口的逻辑是：

（1）查询获票数接口，先查询 redis，如果存在直接，返回即可，如果不存在，说明过期了，需要去数据库拿出来更新；600pqs
    每次票数失效了，只会有一个请求能去数据库查询并更新缓存，其他请求阻塞等待。这里之所以发现这个缓存穿透的问题，是因为在测试该接口的时候，发现了慢sql，这里分析可能是由于多个请求同时去访问mysql，我们的核只有2个，导致，最后访问msql的那几个请求，等了很久。

优化：缓存失效后，获取到分布式锁的请求，才能去数据库拿数据，更新缓存。其他请求，在这一段时间内，重试一定的次数，并睡眠一定时间，重新从缓存中拿数据。

并且可以加随机的50毫秒，来避免缓存雪崩，但优化之后，影响我们的性能，将优化删掉了。600qps。
（2）获取当前有效票据：是直接在本地进行更新的，如果时间到了，直接在本地生成新的，并且进行替换，800qps

（3）投票：先检查当前票据是否还有效（本地执行，快），若有效再检查是否超过使用次数（去数据库中查询使用次数是否超过最大使用次数，慢），没有超过最大使用次数，就把使用次数++；再获取 redis 分布式锁，拿到锁的请求，就可以去mysql中投票（慢）150qps
这里准备优化，在更新有效票据的时候，也放到redis中去，并且在redis中进行检查是否过期或超过最大使用次数（快），如果没有就让该请求去投票（慢）初步优化到268qps。

仍然使用redis分布式锁的方式，会存在大量的请求获取不到redis锁，阻塞；160pqs左右

选择自己实现的乐观锁去投票，同样会导致大量的请求阻塞在mysql，268qps左右。

下阶段准备优化投票方式，选择先在redis中累加，然后定期刷盘到mysql中。

优化投票方式，项目启动时，自动到数据库中拉取所有用户当前投票数，然后后续投票接口通过在redis中累加，定时刷盘到redis中，测试后qps达到450。

再次进行测试，解决了一些小bug，然后整体测试下来没有问题，加了优雅关闭程序，保证我们主动关闭项目时，redis中的投票数据能够刷入mysql，并且在项目关闭后，会对redis中的数据进行清除。
在下次项目启动时，会自动将选手信息、有效票据加入 redis 中。

目前发现热更有点问题，能更新，但是重新修改的配置，不能读入项目中，需要重启才行。所以，这里热更生效。
